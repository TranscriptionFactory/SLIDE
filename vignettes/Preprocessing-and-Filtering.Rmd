---
title: "Preprocessing-and-Filtering"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Preprocessing-and-Filtering}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Overview
SLIDE uses the feature-feature correlation structure in the data to create latent factors. Input data does not need to be autoscaled (meaning each feature has `mean = 0` and `std dev = 1`), as this is done when calculating the latent factors. However, there are a few important considerations:

* Normalization is still recommended (such as normalizing for read-depth or library size); other transformations (log, power,etc) may be recommended for specific data types. 
* `thresh_fdr` argument sets the threshold below which correlations (in the scaled correlation matrix) will be removed. The default is `0.2`, but use a lower value to get more diverse latent factors.
  + Occasionally, `thresh_fdr` and `delta` will cause the algorithm to fail because the remaining correlations in the data are too sparse and more than `delta` apart from each other. Consider lowering both if you encounter problems.

## Missing Values
* Imputation
* 

## Filtering
* **Sparsity**: both in features and samples will create problems. Consider removing features, then samples based on sparsity (generally, any sample filtering should come after feature filtering). 
  + A good initial check is to see how many features have `median = 0` (50% of feature are zeros) - if there are a significant number of these features, instead of removing all of them consider removing features that have more than 50% zeros (e.g. remove features that are 90% zeros or 75% zeros). Afterwards, do the same for samples (although we are generally more conservative and only remove samples that have a significant proportion of zeros).
* **Variance**: Low variance features are less informative, so Consider filtering these out. 
  + Remove features with `std dev = 0`, because these are uninformative
* **Coefficient of Variation**: Ratio of feature `std dev / mean`. Features with high coefficient of variation may be noise and features with low coefficient of variation may be uninformative.



Below are some examples of how you can do this (note, download these files from the examples folder on the SLIDE repo at jishnu-lab/SLIDE):
```{r load_example_data}
unfiltered_x = as.matrix(read.csv('/ix/djishnu/Aaron/1_general_use/SLIDE/Data_Scripts/CD4_Expansion/x.csv', row.names = 1))
unfiltered_y = as.matrix(read.csv('/ix/djishnu/Aaron/1_general_use/SLIDE/Data_Scripts/CD4_Expansion/y.csv', row.names = 1))


x = unfiltered_x
y = unfiltered_y
```


## Sparsity Filtering
You can measure the proportion of zeros in each row/column. Start by filtering out features, then filter samples
```{r sparsity-filter}
proportion_col_zeros = apply(x, 2, function(x) length(which(x == 0))/length(x))

hist(proportion_col_zeros, xlab = "Proportion/% of Zeros in each column")
```

We can use these vectors with the quantile function to set a threshold for percentage of zeros - note: you don't need to use the quantile function, but it makes for smoother filtering.
```{r sparsity-filter-col}
# Get indices for cols that are the top 10% sparse
cols_above_zero_threshold = which(proportion_col_zeros > quantile(proportion_col_zeros, 0.9))

x = x[, -cols_above_zero_threshold]
```

Now do the same for rows (remember to remove the corresponding rows from your response vector as well!)
```{r sparsity-filter-rows}
# Get indices for rows that are the top 10% sparse
proportion_row_zeros = apply(x, 1, function(x) length(which(x == 0))/length(x))

hist(proportion_row_zeros, xlab = "Proportion/% of Zeros in each row")

rows_above_zero_threshold = which(proportion_row_zeros > quantile(proportion_row_zeros, 0.9))
x = x[-rows_above_zero_threshold, ]

```

Note: you may want to just remove any columns or rows that have 90% zeros (versus just filtering out by quantile); in this case, your apply function will not normalize for length:
```{r absolute-sparsity-filtering}
absolute_num_col_zeros = apply(x, 2, function(x) length(which(x == 0)))
absolute_num_row_zeros = apply(x, 1, function(x) length(which(x == 0)))

# should look the same as hist for row % above
hist(absolute_num_row_zeros)
```


<!-- You can measure the proportion of zeros in each row/column -->
<!-- ```{r sparsity-filter} -->
<!-- proportion_row_zeros = apply(x, 1, function(x) length(which(x == 0))/length(x)) -->
<!-- proportion_col_zeros = apply(x, 2, function(x) length(which(x == 0))/length(x)) -->

<!-- hist(proportion_col_zeros, xlab = "Proportion/% of Zeros in each column") -->
<!-- hist(proportion_row_zeros, xlab = "Proportion/% of Zeros in each row") -->

<!-- ``` -->

<!-- We can use these vectors with the quantile function to set a threshold for percentage of zeros - note: you don't need to use the quantile function, but it makes for smoother filtering. -->
<!-- ```{r sparsity-filter} -->

<!-- # Get indices for row/column that are the top 10% sparse -->
<!-- max_proportion_col_zeros = which(proportion_col_zeros > quantile(proportion_col_zeros, 0.9)) -->

<!-- max_proportion_row_zeros = which(proportion_row_zeros > quantile(proportion_row_zeros, 0.9)) -->


<!-- ``` -->



<!-- Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format: -->

<!-- - Never uses retina figures -->
<!-- - Has a smaller default figure size -->
<!-- - Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style -->

<!-- ## Vignette Info -->

<!-- Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette. -->

<!-- ## Styles -->

<!-- The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows: -->

<!--     output:  -->
<!--       rmarkdown::html_vignette: -->
<!--         css: mystyles.css -->

<!-- ## Figures -->

<!-- The figure sizes have been customised so that you can easily put two images side-by-side.  -->

<!-- ```{r, fig.show='hold'} -->
<!-- plot(1:10) -->
<!-- plot(10:1) -->
<!-- ``` -->

<!-- You can enable figure captions by `fig_caption: yes` in YAML: -->

<!--     output: -->
<!--       rmarkdown::html_vignette: -->
<!--         fig_caption: yes -->

<!-- Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**. -->

<!-- ## More Examples -->

<!-- You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`. -->

<!-- ```{r, echo=FALSE, results='asis'} -->
<!-- knitr::kable(head(mtcars, 10)) -->
<!-- ``` -->

<!-- Also a quote using `>`: -->

<!-- > "He who gives up [code] safety for [code] speed deserves neither." -->
<!-- ([via](https://twitter.com/hadleywickham/status/504368538874703872)) -->
